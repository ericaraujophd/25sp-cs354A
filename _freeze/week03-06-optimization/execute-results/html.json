{
  "hash": "902a4c989e32e0f7403f580c9935da2d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Week 03: SLO 06 ‚Äì Optimize SQL Queries for Better Performance\"\nauthor: \"Eric Araujo\"\nformat:\n  html:\n    code-fold: false\njupyter: python3\n---\n\n## üéØ Why It Matters\n\nWell-optimized SQL queries:\n\n* Run faster\n* Reduce memory and CPU usage\n* Improve scalability for large datasets\n\nEven in SQLite, which is lightweight and file-based, writing efficient queries is essential, especially when working with large tables or complex joins.\n\n## üîß Key Techniques & Examples\n\n### 1. Use SELECT Only What You Need\n\nAvoid `SELECT *` ‚Äî only select necessary columns.\n\n```sql\n-- Bad\nSELECT * FROM orders;\n\n-- Good\nSELECT order_id, order_date FROM orders;\n```\n\nüîç In other DBMSs, `SELECT *` can even prevent index-only scans (e.g., PostgreSQL). In DBMSs like PostgreSQL, an index-only scan is a powerful optimization. It allows the database to read data directly from the index without having to access the full table (also called the heap). This is much faster, especially on large tables.\n\nBut for this to work, two things must be true:\n\n1.\tAll the required columns must be in the index\n2.\tThere must be no need to access the actual table rows\n\n**SQLite** does not support index-only scans in the same way **PostgreSQL** does. So in SQLite, this specific optimization doesn‚Äôt apply ‚Äî but it‚Äôs still a good habit to avoid SELECT * for performance and clarity.\n\n### 2. Filter Early with WHERE\n\nApply `WHERE` clauses to reduce the number of rows processed.\n\n```sql\n-- Bad\nSELECT customer_id FROM orders;\n\n-- Good\nSELECT customer_id FROM orders WHERE order_date > '2024-01-01';\n```\n\nIn **SQLite**, filtering helps avoid unnecessary disk reads since it uses B-Trees for indexes.\n\n### 3. Use Indexes Wisely\n\nIndexes speed up `WHERE`, `JOIN`, and `ORDER BY`. But avoid over-indexing!\n\n```sql\n-- Create index on order_date for filtering\nCREATE INDEX idx_orders_order_date ON orders(order_date);\n```\n\nIn PostgreSQL, you can use `EXPLAIN` to see if indexes are used. In SQLite, use `EXPLAIN QUERY PLAN`.\n\nAn **index** is like a sorted list that a database uses to quickly find data in a table ‚Äî similar to an index in a book.\n\nInstead of scanning every row (called a full table scan), the database looks in the index to jump directly to the relevant rows, which is much faster.\n\nüìå Key Points about Indexes\n\n* Speeds up WHERE, JOIN, and ORDER BY queries.\n* Uses extra disk space.\n* Too many indexes = slower inserts/updates (because all indexes need updating).\n* Best used on columns frequently used in filtering or joining.\n\n### 4. Avoid Functions on Indexed Columns\n\nUsing functions on columns disables index use.\n\n```sql\n-- Bad (no index use)\nSELECT * FROM orders WHERE strftime('%Y', order_date) = '2024';\n\n-- Good\nSELECT * FROM orders WHERE order_date >= '2024-01-01' AND order_date < '2025-01-01';\n```\n\n### 5. Use EXISTS Instead of IN for Subqueries\n\n```sql\n-- Slower for large subqueries\nSELECT name FROM customers \nWHERE customer_id IN (SELECT customer_id FROM orders);\n\n-- Faster with EXISTS\nSELECT name FROM customers c\nWHERE EXISTS (\n  SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id\n);\n```\n\nThis query retrieves the names of customers who have at least one order.\n\nIn **SQLite**, both are often converted internally, but `EXISTS` is still preferable with correlated subqueries.\n\nThe subquery\n\n```sql\nSELECT 1 FROM orders o WHERE o.customer_id = c.customer_id\n```\n\nsays: \"Is there at least one order where orders.customer_id = this customer‚Äôs ID?\". If yes, the customer is included in the result.\n\n:::{.callout-important}\nSELECT 1 just returns a dummy value ‚Äî it could be `SELECT *` or `SELECT 'x'`; it doesn‚Äôt matter because EXISTS only cares about the existence of at least one matching row.\n:::\n\nThis is often faster than:\n\n```sql\nSELECT name FROM customers\nWHERE customer_id IN (SELECT customer_id FROM orders);\n```\n\nBecause `EXISTS` can stop searching early (as soon as it finds a match), while `IN` may need to collect all values first, depending on the DBMS.\n\n### 6. Use JOINs Instead of Subqueries (when appropriate)\n\n```sql\n-- Subquery\nSELECT name FROM customers \nWHERE customer_id IN (\n  SELECT customer_id FROM orders WHERE total > 100\n);\n\n-- JOIN (may perform better)\nSELECT DISTINCT c.name \nFROM customers c\n    JOIN orders o ON c.customer_id = o.customer_id\nWHERE o.total > 100;\n```\n\nIn **MySQL** and **PostgreSQL**, query planners can optimize JOINs more effectively.\n\n### 7. Limit Result Set with LIMIT\n\nAlways add a LIMIT for preview or pagination.\n\n```sql\nSELECT * FROM logs ORDER BY created_at DESC LIMIT 100;\n```\n\n## üîç SQLite-Specific Tips\n\n### A. Use ANALYZE to collect statistics and help the query planner:\n\n```sql\nANALYZE;\n```\n\n`ANALYZE` is a command that collects statistics about the contents of tables and indexes. These statistics help SQLite‚Äôs query planner make better decisions when optimizing queries.\n\nYou can also analyze a specific table or index:\n\n```sql\nANALYZE orders;\n```\n\nüìà What It Does\n\n* Stores the data distribution and row counts in a system table called sqlite_stat1.\n* Helps SQLite decide:\n  * Which index to use\n  * Whether to use an index at all\n  * The best join order\n\nüìå When to Use\n\n* After creating new indexes\n* After loading a large amount of data\n* After major updates or deletes\n\nIt does not run automatically ‚Äî you should run it manually when needed.\n\n### B. Use EXPLAIN QUERY PLAN to understand what SQLite is doing:\n\n```sql\nEXPLAIN QUERY PLAN SELECT * FROM orders WHERE order_date > '2024-01-01';\n```\n\n`EXPLAIN` is a command that shows how SQLite will **execute a SQL statement**, step by step.\nIt‚Äôs used to **understand and debug query performance**.\n\nüîç Two Versions\n\n#### 1. EXPLAIN\n\nShows low-level virtual machine instructions (for advanced debugging).\n\n```sql\nEXPLAIN SELECT * FROM orders;\n```\n\n* Output: Virtual opcodes (not beginner-friendly)\n* Use if you‚Äôre deep into SQLite internals\n\n#### 2. EXPLAIN QUERY PLAN\n\nThe one you‚Äôll use most. It gives a high-level overview of the query plan.\n\n```sql\nEXPLAIN QUERY PLAN \nSELECT * FROM orders WHERE order_date > '2024-01-01';\n```\n\nTells you:\n\n* Which index (if any) is used\n* Whether it does a full table scan\n* The join order\n\nüìå When to Use\n\n* To check if indexes are being used\n* To spot slow queries doing full scans\n* Before/after ANALYZE to see improvements\n\n[Here is](week02-analyze.ipynb) an example of the output you might see.\n\n## üÜö Comparisons to Other DBMSs\n\n| Optimization Tip        | SQLite                      | PostgreSQL                     | MySQL                          |\n|-------------------------|-----------------------------|--------------------------------|--------------------------------|\n| Index Support           | B-tree only                 | B-tree, GiST, GIN, BRIN        | B-tree, Full-text              |\n| Query Plan Tool         | `EXPLAIN QUERY PLAN`        | `EXPLAIN (ANALYZE, BUFFERS)`   | `EXPLAIN`                      |\n| Parallel Query Support  | ‚ùå No                        | ‚úÖ Yes                          | ‚úÖ Limited                     |\n| Optimizer Complexity    | Simple                      | Advanced (cost-based)          | Moderate                       |\n\n",
    "supporting": [
      "week03-06-optimization_files"
    ],
    "filters": [],
    "includes": {}
  }
}