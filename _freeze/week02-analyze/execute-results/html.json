{
  "hash": "b02004dc96f9d05c31518adc9101054c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Week 02: SQL – ANALYZE\"\nauthor: \"Eric Araujo\"\ndate: \"2025-04-01\"\nformat:\n  html:\n    code-fold: true\n    code-tools: true\njupyter: python3\n---\n\n::: {#cell-1 .cell execution_count=1}\n``` {.python .cell-code}\n%%capture\n%load_ext sql\n%sql sqlite:///dbs/w02/analyze-example.db\n%config SqlMagic.style = '_DEPRECATED_DEFAULT'\n```\n:::\n\n\n## 1. Create a Table and Insert Data\n\n::: {#cell-3 .cell execution_count=2}\n``` {.python .cell-code}\n%%sql\n\nDROP TABLE IF EXISTS orders;\n\nCREATE TABLE orders (\n  order_id INTEGER PRIMARY KEY,\n  customer_id INTEGER,\n  order_date TEXT,\n  total REAL\n);\n\n-- Insert 10,000 rows\nWITH RECURSIVE cnt(x) AS (\n  SELECT 1\n  UNION ALL\n  SELECT x + 1 FROM cnt WHERE x < 10000\n)\nINSERT INTO orders (customer_id, order_date, total)\nSELECT \n  ABS(RANDOM() % 100), \n  date('2024-01-01', '+' || (RANDOM() % 365) || ' days'), \n  ROUND(RANDOM() % 500, 2)\nFROM cnt;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n * sqlite:///dbs/w02/analyze-example.db\nDone.\nDone.\nDone.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n[]\n```\n:::\n:::\n\n\nThis generates 10,000 synthetic rows with:\n\n* customer_id between 0 and 99\n* order_date in the year 2024\n* total up to 500\n\n## 2. Create an Index\n\n::: {#cell-6 .cell execution_count=3}\n``` {.python .cell-code}\n%%sql\nCREATE INDEX idx_orders_order_date ON orders(order_date);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n * sqlite:///dbs/w02/analyze-example.db\nDone.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[]\n```\n:::\n:::\n\n\n## 3. Run a Query and Check the Plan\n\n::: {#cell-8 .cell execution_count=4}\n``` {.python .cell-code}\n%%sql\nEXPLAIN QUERY PLAN\nSELECT * FROM orders WHERE order_date > '2024-06-01';\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n * sqlite:///dbs/w02/analyze-example.db\nDone.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<table>\n    <thead>\n        <tr>\n            <th>id</th>\n            <th>parent</th>\n            <th>notused</th>\n            <th>detail</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>3</td>\n            <td>0</td>\n            <td>205</td>\n            <td>SEARCH orders USING INDEX idx_orders_order_date (order_date&gt;?)</td>\n        </tr>\n    </tbody>\n</table>\n```\n:::\n:::\n\n\nBefore ANALYZE, SQLite might not use the index if it doesn’t know how selective `order_date` is.\n\nIn our case, the query is optimized and using the index. Let's see what the output means.\n\n| Part                                | Meaning                                                                 |\n|-------------------------------------|--------------------------------------------------------------------------|\n| `SEARCH orders`                     | SQLite is accessing the `orders` table using a search operation.        |\n| `USING INDEX idx_orders_order_date` | It is using the `idx_orders_order_date` index to speed up the lookup.   |\n| `(order_date>?)`                    | The filter condition is `order_date > ?` (where `?` is the input value). |\n\nThis shows that SQLite (1) is not scanning the full table and (2) is using the index you created to efficiently jump to rows matching the condition.\n\nHad the query said something like:\n\n```sql\nSCAN TABLE orders\n```\n\n...that would mean a **full table scan** — which is slower, especially on large datasets.\n\n\n## 4. Run ANALYZE\n\nThis updates the sqlite_stat1 table with stats about the distribution of values in the table/indexes.\n\n::: {#cell-11 .cell execution_count=5}\n``` {.python .cell-code}\n%%sql\nANALYZE;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n * sqlite:///dbs/w02/analyze-example.db\nDone.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[]\n```\n:::\n:::\n\n\n::: {#cell-12 .cell execution_count=6}\n``` {.python .cell-code}\n## 5. Run the Same Query Again\n```\n:::\n\n\n::: {#cell-13 .cell execution_count=7}\n``` {.python .cell-code}\n%%sql\nEXPLAIN QUERY PLAN\nSELECT * FROM orders WHERE order_date > '2024-06-01';\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n * sqlite:///dbs/w02/analyze-example.db\nDone.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<table>\n    <thead>\n        <tr>\n            <th>id</th>\n            <th>parent</th>\n            <th>notused</th>\n            <th>detail</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>3</td>\n            <td>0</td>\n            <td>140</td>\n            <td>SEARCH orders USING INDEX idx_orders_order_date (order_date&gt;?)</td>\n        </tr>\n    </tbody>\n</table>\n```\n:::\n:::\n\n\nAfter `ANALYZE`, you’ll likely see that the index is now being used, especially if the planner sees it as more efficient.\n\n",
    "supporting": [
      "week02-analyze_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}