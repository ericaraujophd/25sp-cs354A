{
  "hash": "a8e53f605dfe210710f2cfa2fa0a8217",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Week 02: SQL ‚Äì Intermediate Concepts Summary\"\nformat:\n  html:\n    code-fold: false\njupyter: python3\n---\n\n## SLOs for Week 02\n\nAt the end of this unit, students will be able to...\n\n1.  Perform data aggregation using GROUP BY and HAVING.\n2.  Write and execute INNER, LEFT-OUTER, RIGHT, and FULL JOINs.\n3.  Construct subqueries for complex queries.\n4.  Implement SQL functions and expressions.\n5.  Use SQL best practices for readable and efficient queries.\n\n::: {#cell-2 .cell execution_count=1}\n``` {.python .cell-code}\n%%capture\n%load_ext sql\n%sql sqlite:///dbs/w02/library.db\n%config SqlMagic.style = '_DEPRECATED_DEFAULT'\n```\n:::\n\n\n## üßÆ 1. SQL Aggregation & Grouping (with SQLite Notes)\n\nSQL lets you **summarize** data using **aggregate functions**, and **group** it with GROUP BY. This is especially helpful for statistics, reports, and dashboards.\n\n### üéØ **Common Aggregate Functions**\n\n| Function  | Description     | Example       |\n|-----------|-----------------|---------------|\n| `COUNT()` | Number of rows  | `COUNT(*)`    |\n| `SUM()`   | Total of values | `SUM(amount)` |\n| `AVG()`   | Mean average    | `AVG(score)`  |\n| `MIN()`   | Smallest value  | `MIN(age)`    |\n| `MAX()`   | Largest value   | `MAX(salary)` |\n\n::: callout-note\n‚úÖ **SQLite supports all these functions.**\n:::\n\n\n### üß© Basic Grouping Example\n\n**Q:** How many students are in each major?\n\n``` sql\nSELECT major, COUNT(*) AS student_count\nFROM students\nGROUP BY major;\n```\n\n::: callout-note\n‚úÖ SQLite allows this even if you‚Äôre selecting columns not in the GROUP BY clause or not inside an aggregate function. It will return one arbitrary value from each group for such columns.\n:::\n\n**Example (SQLite accepts this):**\n\n``` sql\nSELECT major, name\nFROM students\nGROUP BY major;\n```\n\n::: callout-note\nThis works in SQLite ‚Äî it will return one name for each major, but which name is returned is undefined. ‚ùå PostgreSQL (and other standards-compliant SQL engines) will **reject** this query with an error unless name is also in the GROUP BY or wrapped in an aggregate like MIN(name).\n:::\n\n### üîç Filtering Groups with HAVING\n\nUse HAVING to filter after grouping.\n\n**Q:** Show only majors with more than 10 students:\n\n``` sql\nSELECT major, COUNT(*) AS student_count\nFROM students\nGROUP BY major\nHAVING COUNT(*) > 10;\n```\n\n::: callout-note\n‚ÑπÔ∏è In SQLite, you can refer to the alias (student_count) in HAVING. In PostgreSQL, you‚Äôd need to repeat the expression: HAVING COUNT(\\*) \\> 10.\n:::\n\n### üìä Combining Aggregates\n\n**Q:** Show average GPA per department ‚Äî only if it‚Äôs above 3.5:\n\n``` sql\nSELECT department, AVG(gpa) AS avg_gpa\nFROM students\nGROUP BY department\nHAVING AVG(gpa) > 3.5;\n```\n\n### üîó Grouping by Expressions\n\nYou can group by computed values like substrings or date parts.\n\n**Q:** Count students by **admission year** (from text-based dates):\n\n``` sql\nSELECT SUBSTR(admission_date, 1, 4) AS year, COUNT(*) AS num_students\nFROM students\nGROUP BY year;\n```\n\nThe SUBSTR() function extracts a **substring** from a given string.\n\n``` sql\nSUBSTR(string, start, length)\n```\n\n-   string: the text to extract from\n-   start: the position to start (1-based index)\n-   length (optional): how many characters to return\n\n``` sql\n-- Get the first 4 characters of a date\nSELECT SUBSTR('2024-09-15', 1, 4);  -- Returns '2024'\n\n-- Get the first letter of a name\nSELECT SUBSTR(name, 1, 1) FROM students;\n```\n\nüìå If length is omitted, SQLite returns the rest of the string from start.\n\n::: callout-note\n‚úÖ Works well in SQLite (which stores dates as text: YYYY-MM-DD). ‚ùó In PostgreSQL, use: EXTRACT(YEAR FROM admission_date).\n:::\n\n### üß† Tips for Grouping Queries\n\n-   Use GROUP BY with aggregate functions.\n-   Use HAVING to filter groups (not rows).\n-   Use WHERE for filtering before grouping.\n-   Prefer column names or expressions in GROUP BY, not just positions (e.g., avoid GROUP BY 1).\n-   Be cautious using non-aggregated, non-grouped columns in SQLite ‚Äî it‚Äôs allowed, but not portable or predictable.\n\n",
    "supporting": [
      "week02-notes_files"
    ],
    "filters": [],
    "includes": {}
  }
}