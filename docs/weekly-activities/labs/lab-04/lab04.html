<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 4: Vec – A First Dynamic Data Structure – CS112 - Data Structures</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../.././images/cs112-logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://kit.fontawesome.com/78ddb093ea.js" crossorigin="anonymous"></script>


<meta property="og:title" content="Lab 4: Vec – A First Dynamic Data Structure – CS112 - Data Structures">
<meta property="og:description" content="CS112 will teach students to use C++ for creating data structures.">
<meta property="og:site_name" content="CS112 - Data Structures">
<meta name="twitter:title" content="Lab 4: Vec – A First Dynamic Data Structure – CS112 - Data Structures">
<meta name="twitter:description" content="CS112 will teach students to use C++ for creating data structures.">
<meta name="twitter:image" content="https://ericaraujo.com/24fa-cs112/images/twitter-card.png">
<meta name="twitter:creator" content="@ericfaraujo">
<meta name="twitter:image-height" content="500">
<meta name="twitter:image-width" content="500">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../images/cs112-logo.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../policies.html"> 
<span class="menu-text">Course Policies</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content.html"> 
<span class="menu-text">Content</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../extras.html"> 
<span class="menu-text">Extras</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/ericaraujophd/24fa-cs112"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#objectives" id="toc-objectives" class="nav-link active" data-scroll-target="#objectives">Objectives:</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#step-1.-getting-started" id="toc-step-1.-getting-started" class="nav-link" data-scroll-target="#step-1.-getting-started">Step 1. Getting Started</a></li>
  <li><a href="#step-2.-instance-variables" id="toc-step-2.-instance-variables" class="nav-link" data-scroll-target="#step-2.-instance-variables">Step 2. Instance Variables</a></li>
  <li><a href="#step-3.-the-default-constructor" id="toc-step-3.-the-default-constructor" class="nav-link" data-scroll-target="#step-3.-the-default-constructor">Step 3. The Default Constructor</a></li>
  <li><a href="#step-4.-the-explicit-value-constructor" id="toc-step-4.-the-explicit-value-constructor" class="nav-link" data-scroll-target="#step-4.-the-explicit-value-constructor">Step 4. The Explicit-Value Constructor</a></li>
  <li><a href="#step-5.-getting-the-value-of-an-item" id="toc-step-5.-getting-the-value-of-an-item" class="nav-link" data-scroll-target="#step-5.-getting-the-value-of-an-item">Step 5. Getting the Value of an Item</a></li>
  <li><a href="#step-6.-setting-the-value-of-an-item" id="toc-step-6.-setting-the-value-of-an-item" class="nav-link" data-scroll-target="#step-6.-setting-the-value-of-an-item">Step 6. Setting the Value of an Item</a></li>
  <li><a href="#step-7.-the-copy-constructor" id="toc-step-7.-the-copy-constructor" class="nav-link" data-scroll-target="#step-7.-the-copy-constructor">Step 7. The Copy Constructor</a></li>
  <li><a href="#step-8.-the-destructor" id="toc-step-8.-the-destructor" class="nav-link" data-scroll-target="#step-8.-the-destructor">Step 8. The Destructor</a></li>
  <li><a href="#step-9.-setting-a-vecs-size" id="toc-step-9.-setting-a-vecs-size" class="nav-link" data-scroll-target="#step-9.-setting-a-vecs-size">Step 9. Setting a Vec’s Size</a></li>
  <li><a href="#step-10.-equality" id="toc-step-10.-equality" class="nav-link" data-scroll-target="#step-10.-equality">Step 10. Equality</a></li>
  <li><a href="#step-11.-ostream-output" id="toc-step-11.-ostream-output" class="nav-link" data-scroll-target="#step-11.-ostream-output">Step 11. ostream Output</a></li>
  <li><a href="#step-12.-istream-input" id="toc-step-12.-istream-input" class="nav-link" data-scroll-target="#step-12.-istream-input">Step 12. istream Input</a></li>
  <li><a href="#submit" id="toc-submit" class="nav-link" data-scroll-target="#submit">Submit</a></li>
  <li><a href="#grading-rubric-24-pts-total" id="toc-grading-rubric-24-pts-total" class="nav-link" data-scroll-target="#grading-rubric-24-pts-total">Grading Rubric: 24 pts total</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/ericaraujophd/24fa-cs112/edit/main/weekly-activities/labs/lab-04/lab04.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/ericaraujophd/24fa-cs112/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 4: Vec – A First Dynamic Data Structure</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="objectives" class="level2">
<h2 class="anchored" data-anchor-id="objectives">Objectives:</h2>
<p>In this exercise, you will:</p>
<ol type="1">
<li>Build a class that uses dynamic allocation/deallocation.</li>
<li>Use pointer variables to access items in a dynamically-allocated array.</li>
</ol>
<!-- ![A student created by AI](imgs/student-cover.jpeg "A cartoon style image of a computer science student wearing a T-shirt with a binary code pattern") -->
<center>
<figure class="figure">
<img src="imgs/data-structures.jpeg" alt="An array for a data structures assignment (created by AI)" width="400" class="figure-img">
<figcaption>
An array for a data structures assignment created by AI.
</figcaption>
</figure>
</center>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>You should know how to <a href="https://classroom.github.com/a/VP5OQop2">get the assignment</a>. So, do it.</p>
<ul>
<li>Don’t forget to edit the README.md file and put both of your names and emails in the file.</li>
<li>You might also at this time Manage Access to the repo, so that both of you can access it.</li>
</ul>
<p>The Vec class is a simpler version of the vector<t> class template available in the C++ standard template library (STL). It will provide the basic functionality, without some of the more advanced “bells and whistles” of the STL version.</t></p>
<p>The class in <code>Vec.h</code> is a mere shell at this point. Filling in this shell is our task this week.</p>
</section>
<section id="step-1.-getting-started" class="level2">
<h2 class="anchored" data-anchor-id="step-1.-getting-started">Step 1. Getting Started</h2>
<ul>
<li>Open each file and take a moment to browse through them, to get a sense of what each one contains. Note that <code>test.cpp</code> contains tests for a variety of Vec operations.</li>
</ul>
<p>Our approach today will be to use the following steps to build each operation: - This exercise will provide you with a description of what the operation should do, and a stub for the method that provides that operation; - You will uncomment the call to the test for that operation in <code>tests.cpp</code> - You will complete the method by adding statements to the stub; and - You will compile and run the project. (do <code>make tester &amp;&amp; ./tester</code>)</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Compile. debug and fix any errors.
</div>
</div>
<div class="callout-body-container callout-body">
<p>If all is well, you can then proceed to the next operation; otherwise you will need to debug your operation to figure out why it is failing the test, recompile, and rerun the test, until it is passed.</p>
</div>
</div>
</section>
<section id="step-2.-instance-variables" class="level2">
<h2 class="anchored" data-anchor-id="step-2.-instance-variables">Step 2. Instance Variables</h2>
<p>If you look in <code>Vec.h</code>, you’ll see that we are (for now) using a typedef to define the identifier Item as a synonym for the type double.</p>
<p>You’ll also see that the <code>private:</code> section of class Vec is currently empty. As a minimalist dynamic array, our Vec will need to “remember” two things:</p>
<ol type="1">
<li>How many Items it is currently storing; and</li>
<li>The Items it is currently storing.</li>
</ol>
<p>To let a Vec “remember” the first of these, add an instance variable named <code>mySize</code> of type unsigned:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span><span class="op">:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     <span class="dt">unsigned</span> mySize<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To let a Vec “remember” the second of these, add an instance variable named <code>myArray</code> capable of storing the address of an Item:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span><span class="op">:</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>     <span class="dt">unsigned</span> mySize<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>     Item   <span class="op">*</span>myArray<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With these two variables, a Vec object can “remember” (i) how many items it is storing, and (ii) the address of a dynamically allocated array in which its items are stored.</p>
<!-- :::{.callout-caution}
## Compile
The compilation should fail because we haven't defined getMajor() yet. There should be no other problems.
:::

:::{.callout-note}
## NOTE
Don't delete any old tests -- just keep adding more. Put each test in its own SECTION within the "Student class" TEST_CASE.
::: -->
</section>
<section id="step-3.-the-default-constructor" class="level2">
<h2 class="anchored" data-anchor-id="step-3.-the-default-constructor">Step 3. The Default Constructor</h2>
<p>The role of the default constructor is to provide the instance variables with default values. In a data structure, these are usually values that are appropriate for an “empty” structure. In <code>Vec.cpp</code>, complete the default constructor for the class, so that it sets <code>mySize</code> to zero, and sets <code>myArray</code> to <strong>nullptr</strong>. Compile and run the project (<code>make tester &amp;&amp; ./tester</code>).</p>
<p>The test should pass, but notice that it isn’t actually doing anything… To make a useful test, we need to see if <code>mySize</code> is 0 and <code>myArray</code> is <strong>nullptr</strong>. However, <code>myArray</code> and <code>mySize</code> are private, so the test cannot “reach into” the innards of the Vec object to check the values. To resolve this, we will create a getter for <code>mySize</code>. In the .h file, in the <code>public:</code> section, add the prototypes:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> getSize<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the Vec.cpp file, add this code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> Vec<span class="op">::</span>getSize<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>and finish the code which returns mySize.</p>
<p>Notice that we are NOT going to add a getter method for myArray, which would allow a user of the Vec class to get the address where the values are being stored. We do not want to expose this internal detail to the user, as the user could abuse it and start putting values directly into memory. So, because we won’t make a getter for myArray, we won’t be able to make tests to check the value of myArray.</p>
<p>Uncomment the lines in the first (“default”) <code>SECTION</code> and compile and run (<code>make tester &amp;&amp; ./tester</code>).</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Before you go the next step!
</div>
</div>
<div class="callout-body-container callout-body">
<p>When your definition passes the test, continue; otherwise fix and retest your constructor.</p>
</div>
</div>
</section>
<section id="step-4.-the-explicit-value-constructor" class="level2">
<h2 class="anchored" data-anchor-id="step-4.-the-explicit-value-constructor">Step 4. The Explicit-Value Constructor</h2>
<p>The explicit-value constructor’s role is to initialize an object using values provided by the user. In a data structure, the user often wants to specify a non-zero starting size for the structure. (e.g., <code>Vec v(5);</code> should construct v as a vector capable of storing 5 items.) To store the value the user specifies, our constructor will need a parameter, so we might start by writing this stub for the constructor:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Vec<span class="op">::</span>Vec<span class="op">(</span><span class="dt">unsigned</span> size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Put the above code in your .cpp file, and add a prototype for this constructor to the Vec class in <code>Vec.h</code>. Then in <code>tests.cpp</code>, uncomment the first 2 lines of code in the “explicit-value” SECTION that tests this constructor. Save/compile/run the tests. The test should fail. To make it pass, add code to your explicit-value constructor. Here is the algorithm to follow:</p>
<ol type="1">
<li>Set mySize to size</li>
<li>If size is positive (greater than zero):
<ul>
<li>Dynamically allocate an array of size values of type Item, and store the address of the array in myArray; and</li>
<li>Set each of the Items in that array to zero.</li>
</ul></li>
<li>Otherwise:
<ul>
<li>Set myArray to nullptr.</li>
</ul></li>
</ol>
<p>Continue when your class passes all tests.</p>
</section>
<section id="step-5.-getting-the-value-of-an-item" class="level2">
<h2 class="anchored" data-anchor-id="step-5.-getting-the-value-of-an-item">Step 5. Getting the Value of an Item</h2>
<p>The rest of the test for the “explicit-value constructor” looks to see if <code>myArray</code> was initialized correctly. In order to do this, we need to be able to retrieve the value in each location in <code>myArray</code>. To do that, we’ll implement a <code>getItem()</code> method that lets us retrieve the value of an item at a given index (e.g., <code>Item it = v.getItem(i);</code>). Since this method (i) needs the index of the value it is to retrieve, and (ii) does not change its receiver’s instance variables, we will start by defining this stub:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Item Vec<span class="op">::</span>getItem<span class="op">(</span><span class="dt">unsigned</span> index<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Place a prototype for this method in the Vec class, and in <code>tests.cpp</code>, uncomment the rest of the test code in the “explicit-value” constructor SECTION. For the sake of time, here is the code for .cpp file:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Item Vec<span class="op">::</span>getItem<span class="op">(</span><span class="dt">unsigned</span> index<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> index <span class="op">&gt;=</span> mySize<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> range_error<span class="op">(</span><span class="st">"Bad index"</span><span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> myArray<span class="op">[</span>index<span class="op">];</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When all tests pass, continue.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>There is a TEST_CASE in tests.cpp to fully test getItem(), but it relies on setItem(), which we have not implemented yet. So, don’t uncomment that test case yet.</p>
</div>
</div>
</section>
<section id="step-6.-setting-the-value-of-an-item" class="level2">
<h2 class="anchored" data-anchor-id="step-6.-setting-the-value-of-an-item">Step 6. Setting the Value of an Item</h2>
<p>Our next operation is to set the value of a particular item in a Vec (e.g., <code>v.setItem(i, val);</code>). Since the method needs both the index of the item to change, and the new value for the item, we will start with this stub:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Vec<span class="op">::</span>setItem<span class="op">(</span><span class="dt">unsigned</span> index<span class="op">,</span> <span class="at">const</span> Item<span class="op">&amp;</span> it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Place a prototype for this method in the Vec class, and in <code>tests.cpp</code>, uncomment the code to test “setItem”.</p>
<p>Try to build and run the test to see what errors you get; then complete the stub so that it passes the test. Again, for the sake of time, here is the code for Vec.cpp</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Vec<span class="op">::</span>setItem<span class="op">(</span><span class="dt">unsigned</span> index<span class="op">,</span> <span class="at">const</span> Item<span class="op">&amp;</span> it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> index <span class="op">&gt;=</span> mySize<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> range_error<span class="op">(</span><span class="st">"Bad index"</span><span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    myArray<span class="op">[</span>index<span class="op">]</span> <span class="op">=</span> it<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When all tests pass for testing setItem, also uncomment the getItem TEST_CASE. If you have everything working, you should be passing 29 assertions in 9 test cases.</p>
</section>
<section id="step-7.-the-copy-constructor" class="level2">
<h2 class="anchored" data-anchor-id="step-7.-the-copy-constructor">Step 7. The Copy Constructor</h2>
<p>The compiler invokes a special copy constructor any time it needs a copy of an object, for example:</p>
<ul>
<li>When a function returns an object; OR</li>
<li>When an object is passed as an argument to a call-by-value parameter.</li>
</ul>
<p>The C++ compiler supplies a default copy constructor, but it merely does a bit-by-bit copy of the instance variables of the object being copied. This bit-copy is inadequate for classes with pointer instance variables, because it just copies the address within such variables, rather than making a distinct copy of the dynamically allocated memory to which that address points. Because of this, <strong>every class that contains a pointer instance variable should define its own copy constructor that makes a distinct copy of the object, including its dynamically allocated memory</strong>.</p>
<p>The stub for a Vec copy constructor looks like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Vec<span class="op">::</span>Vec<span class="op">(</span><span class="at">const</span> Vec<span class="op">&amp;</span> original<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>If we were to mistakenly make the copy constructor’s parameter a call-by-value parameter instead of a call-by-const-reference parameter, an infinite recursion will occur when the copy constructor is invoked. The reason is that passing a Vec to a call-by-value parameter will invoke the copy constructor, which will take the thing to be copied as a parameter, which will invoke the copy constructor, which will take the thing to be copied as a parameter, which will invoke the copy constructor, which… To avoid this, the parameter of a copy constructor should always be a const-reference parameter, as shown above.</p>
</div>
</div>
<p>Add the code above to the .cpp file. Then, add a prototype to the Vec class, and in <code>tests.cpp</code> uncomment the code in the “copy” constructor SECTION to test it. Then add statements to your stub to construct a Vec that is a distinct copy of original, and check to see if the tests pass. Here is the algorithm to follow:</p>
<ol type="1">
<li>Set mySize to the size of original</li>
<li>If <code>original.mySize</code> is greater than zero:
<ol type="1">
<li>Dynamically allocate an array of <code>mySize</code> values of type Item, and store the address of the array in <code>myArray</code>.</li>
<li>Set each item<sub>i</sub> in the new array to item<sub>i</sub> from original.</li>
</ol></li>
<li>Otherwise, set <code>myArray</code> to <code>nullptr</code>.</li>
</ol>
<p>Continue when your constructor passes all tests. (I am now seeing 35 assertions in 9 test cases passing.)</p>
</section>
<section id="step-8.-the-destructor" class="level2">
<h2 class="anchored" data-anchor-id="step-8.-the-destructor">Step 8. The Destructor</h2>
<p>The C++ compiler invokes an object’s <em>destructor</em> when the object ceases to exist. The role of the destructor is thus to perform any “clean up” actions that are needed to return the system to the same state it was in before the object existed. In a data structure that uses dynamic memory allocation, the main task is usually to return dynamically allocated memory to the system using the <strong>delete</strong> operation.</p>
<p>A destructor cannot have any parameters, and its name is the name of the class preceded by the tilde character (~), so we can begin with the stub:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Vec<span class="op">::~</span>Vec<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Skeleton code is already in the .h and .cpp files. Uncomment the code to test the destructor in <code>tests.cpp</code>. Then add the statements to the destructor to reclaim the dynamic array whose address is in <code>myArray</code>, set <code>myArray</code> to nullptr, and set <code>mySize</code> to zero. Compile and see if your statements pass the test. Here is the algorithm to follow:</p>
<ol type="1">
<li>Use <code>delete []</code> to deallocate the array whose address is stored in <code>myArray</code> <code>delete [] myArray;</code></li>
<li>Set <code>myArray</code> to <code>nullptr</code></li>
<li>Set <code>mySize</code> to zero.</li>
</ol>
<p>Technically, only the first step is strictly necessary. The reason is that the destructor is only invoked at the end of an object’s lifetime. Since the object will no longer exist, resetting its instance variables is not necessary (except to pass the test).</p>
<p>Continue when your destructor passes all tests.</p>
</section>
<section id="step-9.-setting-a-vecs-size" class="level2">
<h2 class="anchored" data-anchor-id="step-9.-setting-a-vecs-size">Step 9. Setting a Vec’s Size</h2>
<p>Our next operation is to set a Vec’s size via a method (e.g., <code>v.setSize(8);</code>). The role of this method is to allow us to change the size of an existing Vec to some new size. Since the user must specify this new size, we need a parameter to store it. We might start by defining this stub:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Vec<span class="op">::</span>setSize<span class="op">(</span><span class="dt">unsigned</span> newSize<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Place a prototype for this method in the Vec class, and in <code>tests.cpp</code>, uncomment all the code in the TEST_CASE to test “setSize”. Then complete the stub so that it passes the test. Think carefully! This one is deceptively tricky to get right! Algorithm:</p>
<ol type="1">
<li>If <code>mySize</code> and <code>newSize</code> are different:
<ol type="a">
<li>If <code>newSize</code> is zero:
<ol type="1">
<li>Deallocate <code>myArray</code></li>
<li>Set <code>myArray</code> to <code>nullptr</code></li>
<li>Set <code>mySize</code> to zero.</li>
</ol></li>
<li>Otherwise:
<ol type="1">
<li>Declare a local variable <code>newArray</code> of type <code>Item *</code></li>
<li>Allocate a new dynamic array of <code>newSize</code> Items, storing its address in <code>newArray</code>.</li>
<li>If <code>mySize</code> is less than <code>newSize</code>:
<ol type="1">
<li>Copy <code>mySize</code> values from <code>myArray</code> into <code>newArray</code>.</li>
<li>Set the remaining (<code>newSize - mySize</code>) values to zero.</li>
</ol></li>
<li>Otherwise, just copy <code>newSize</code> values from <code>myArray</code> into <code>newArray</code>.</li>
<li>Set <code>mySize</code> to <code>newSize</code>.</li>
<li>Deallocate <code>myArray</code>.</li>
<li>Set <code>myArray</code> to <code>newArray</code>.</li>
</ol></li>
</ol></li>
</ol>
<p>When your method passes all tests, continue.</p>
</section>
<section id="step-10.-equality" class="level2">
<h2 class="anchored" data-anchor-id="step-10.-equality">Step 10. Equality</h2>
<p>The purpose of the <strong>equality operation</strong> is to let us compare two objects (e.g., <code>if (v1 == v2) { ... }</code>), returning <strong>true</strong> if they are equal, and returning <strong>false</strong> if they are not. Since the equality operation returns a bool value, a call:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>v1 <span class="op">==</span> v2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>will be treated by the compiler as:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>v1<span class="op">.</span><span class="kw">operator</span><span class="op">==(</span>v2<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This equality operator should not change either of its operands. We start by defining this stub:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> Vec<span class="op">::</span><span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Vec<span class="op">&amp;</span> v2<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Place a prototype for this method in the Vec class, and in <code>tests.cpp</code>, uncomment the code to test “equality”. Then add statements to the stub so that it passes the test. Algorithm:</p>
<ol type="1">
<li>Check to see if <code>mySize</code> is NOT the same as the size of v2. If the two vectors are not the same size, return false.</li>
<li>Compare each item<sub>i</sub> in <code>myArray</code> to each item<sub>i</sub> from v2’s array:<br>
If any are not equal, return false.</li>
<li>The two arrays are equal in size, and all their values are the same, so return true.</li>
</ol>
<p>Continue when your method passes all tests.</p>
</section>
<section id="step-11.-ostream-output" class="level2">
<h2 class="anchored" data-anchor-id="step-11.-ostream-output">Step 11. ostream Output</h2>
<p>It is useful to be able to write a vector to an <code>ostream</code>, as this allows us to display it on the screen (or write it to a file via an <code>ofstream</code>). This method should output the values of the items in the Vec, but not its size; if the user wants that size information displayed, they can do that separately using <code>getSize()</code>.</p>
<p>Whereas (i) our method returns nothing to its caller, (ii) it needs to “know” the ostream to which it is to write, (iii) it modifies that ostream by inserting items, and (iv) it should not modify any Vec instance variables, we might begin with this stub:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Vec<span class="op">::</span>writeTo<span class="op">(</span>ostream<span class="op">&amp;</span> out<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Place a prototype for this method in the Vec class, and in <code>tests.cpp</code>, uncomment the test “writeToStream”. Then add statements to this stub so that it passes the test. Algorithm:</p>
<ul>
<li>Send each value in <code>myArray</code> to the out stream, followed by a single space.</li>
</ul>
<p>Continue when your method passes all the tests.</p>
</section>
<section id="step-12.-istream-input" class="level2">
<h2 class="anchored" data-anchor-id="step-12.-istream-input">Step 12. istream Input</h2>
<p>It is also useful to be able to read a vector from an istream, as this lets us enter a vector’s values interactively, from a keyboard (or read them from a file via an <code>ifstream</code>). This method complements <code>writeTo()</code>, and should assume that the user has already constructed the Vec with the appropriate size.</p>
<p>Since (i) our method returns nothing to its caller, (ii) it needs to “know” the istream from which it is to read, (iii) it modifies that istream by extracting items, and (iv) it might modify its instance variables, we might begin with this stub:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Vec<span class="op">::</span>readFrom<span class="op">(</span>istream<span class="op">&amp;</span> in<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Place a prototype for this method in the Vec class, and in <code>tests.cpp</code>, uncomment the test “readFromStream”. Then add statements to this stub so that it passes the test.</p>
<p>Assuming that <code>mySize</code> equals the number of values in in, the Vec <code>readFrom(istream&amp; in)</code> method should:</p>
<ul>
<li>Extract each value from in, storing each in “the next” item of <code>myArray</code>.</li>
</ul>
<p>Continue when your method passes all the tests. (My solution passes ~82 assertions!)</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Congratulations!
</div>
</div>
<div class="callout-body-container callout-body">
<p>You have just built a class that offers the basic functionality one would expect from a vector!</p>
</div>
</div>
</section>
<section id="submit" class="level2">
<h2 class="anchored" data-anchor-id="submit">Submit</h2>
<p>Use VSCode (or the command line) to commit and push your changes to your repo.</p>
<p>To verify your submission to github.com, go to a browser and go to the location of your repo in github.com.</p>
<p>Also, verify that your submission passes all the automated tests in github. The automated tests are the same as those in tests.cpp.</p>
</section>
<section id="grading-rubric-24-pts-total" class="level2">
<h2 class="anchored" data-anchor-id="grading-rubric-24-pts-total">Grading Rubric: 24 pts total</h2>
<ul>
<li>16 pts for correct code that passes all the tests</li>
<li>2 pts for clean, neat code, well-indented, and readable</li>
<li>6 pts for correctness (see common mistakes below).</li>
</ul>
<p>Ways students lost points in the past:</p>
<ul>
<li>-1: Be careful about brace indentation <!-- + -1: Assignment operator leaks memory if the old `mySize > 0` and `original.mySize == 0` (remove Vec.cpp line <redacted>, check instructions carefully) --> <!-- + -1: Tester crashes at line <redacted>, should be < newSize in case newSize is smaller than mySize (otherwise you index past the end of the array) --></li>
<li>-1: Memory leak in <code>setSize()</code> when mySize &lt; newSize. You need to delete[] myArray in both cases; move it outside the else statement.</li>
<li>-2: Make sure you are using <code>delete[]</code> and not <code>delete</code>, which leaks memory</li>
<li>-24: No submission, or partner forgot to include you in README.</li>
</ul>
<!-- [^1]: how to add footnotes. -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ericaraujo\.com\/24fa-cs112");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>This page is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/ericaraujophd/24fa-cs112/edit/main/weekly-activities/labs/lab-04/lab04.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/ericaraujophd/24fa-cs112/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../LICENSE.html">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../../CODE_OF_CONDUCT.html">
<p>Code of Conduct</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>